/**
 * @file can_driver.cpp
 * @author Gento Aiba
 * @brief CAN通信をLinuxで行う
 * @version 2.0
 * @date 2025-05-07
 *
 * @copyright Copyright (c) 2025
 *
 */
#include "ararobo_can/can_driver.hpp"
#include <stdio.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <fcntl.h>
#include <cerrno>

bool CANDriver::isDataAvailable()
{
    fd_set fds;
    struct timeval tv;
    FD_ZERO(&fds);
    FD_SET(can_socket, &fds);
    tv.tv_sec = 0;
    tv.tv_usec = 0;
    int ret = select(can_socket + 1, &fds, NULL, NULL, &tv);
    return ret > 0;
}

void CANDriver::sendPacket(uint16_t id, uint8_t send_buffer[], uint8_t data_length)
{
    can_tx_frame.can_id = id;
    can_tx_frame.can_dlc = data_length;
    for (__u8 i = 0; i < data_length; i++)
    {
        can_tx_frame.data[i] = send_buffer[i];
    }
    ssize_t nbytes = write(can_socket, &can_tx_frame, sizeof(can_tx_frame));
    if (nbytes == -1)
    {
        if (errno == ENOBUFS)
        {
            printf("Retry send packet");
            usleep(1000);
            write(can_socket, &can_tx_frame, sizeof(can_tx_frame));
        }
    }
    if (nbytes != sizeof(can_tx_frame))
    {
        perror("write a frame");
        return;
    }
}

void CANDriver::readPacket(uint8_t *receive_buffer, uint16_t *rx_id, uint8_t *rx_data_length)
{
    rx_numbytes = read(can_socket, &can_rx_frame, sizeof(can_rx_frame));
    if (rx_numbytes < 0)
    {
        perror("read");
    }
    for (uint8_t i = 0; i < can_rx_frame.can_dlc; i++)
    {
        receive_buffer[i] = can_rx_frame.data[i];
    }
    *rx_id = can_rx_frame.can_id;
    *rx_data_length = can_rx_frame.can_dlc;
}

void CANDriver::initCAN()
{
    if ((can_socket = socket(PF_CAN, SOCK_RAW, CAN_RAW)) < 0)
    {
        perror("make socket");
        return;
    }
    strcpy(ifr.ifr_name, "can0");
    if (ioctl(can_socket, SIOCGIFINDEX, &ifr) < 0)
    {
        perror("ioctl");
        return; // エラーが発生した場合、関数を終了
    }
    memset(&addr, 0, sizeof(addr));
    addr.can_family = AF_CAN;
    addr.can_ifindex = ifr.ifr_ifindex;
    if (bind(can_socket, (struct sockaddr *)&addr, sizeof(addr)) < 0)
    {
        perror("bind device");
        return;
    }
    // ソケットを非ブロックモードに設定
    // int flags = fcntl(can_socket, F_GETFL, 0);
    // fcntl(can_socket, F_SETFL, flags | O_NONBLOCK);
}

void CANDriver::closeSocket()
{
    if (close(can_socket) < 0)
    {
        perror("close socket");
    }
}